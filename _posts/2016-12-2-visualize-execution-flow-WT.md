---
layout: post
title: How to process DINAMITE binary traces
---

In this post, we explain how to obtain a high-level summary of the execution using DINAMITE trace analysis tools.

<!--more-->

After [compiling WiredTiger with DINAMITE](https://dinamite-toolkit.github.io/2016/11/12/compiling-WT/) we ran it with the LevelDB dbbench workload called `readseq`.
This workload sequentially iterates over the btree. After obtaining the traces
we went over the following sequence of steps to visualize the execution.

1. Download the binary trace toolkit, which contains loads of useful scripts for
processing and visualizing the traces, and build it:

   ```
   % git clone https://github.com/dinamite-toolkit/dinamite-binary-trace-parser.git
   % cd dinamite-binary-trace-parser
   % INST_LIB=$LLVM_SOURCE/projects/dinamite/library make
   ```
2. After you successfully compile the trace parser, set an environment variable
that will point to its location. This variable will be used later by the trace
processing script:

   ```
   % DINAMITE_TRACE_PARSER="dinamite-binary-trace-parser-directory/trace_parser"
   ```

To make sure the variable sticks around, add the directive to your shell resource
file, such as ```.bashrc```.

3. For convenience, put the traces as well as all the `map_*` files generated
during the DINAMITE compilation into the working directory, where you will process
the traces. Assuming your traces were placed into `/tmp` and you compiled the
program in `$BUILD_DIR` directory, this will do the trick:

   ```
   % mv /tmp/trace.bin.* .
   % cp $BUILD_DIR/map_* .
   ```

   DINAMITE generates a trace file per thread, so you will have as many `trace.bin.*`
   files as there were threads during your execution. The files will be numbered
   sequentially. These numbers are generated by the logging library in the order that
   threads invoke the library (i.e., the first thread that calls the instrumentation
   library will get the id of '1', the second thread will get the id of '2', etc.).
   They have nothing to do with `pthread` thread ids or with application-specific thread
   ids.

4. Now you will need to run a Python script located in the DINAMITE binary trace
parser, which you downloaded in Step 1. This script needs to know where the binary
trace toolkit lives, so you need to set the environment variable
`$DINAMITE_BINTRACE_TOOLKIT` to indicate its location as you invoke the script:

   ```
   % $DINAMITE_BINTRACE_TOOLKIT=/home/dinamite-binary-trace-parser
   % $DINAMITE_BINTRACE_TOOLKIT/process-logs.py trace.bin.*
   ```

   Now sit back and relax or go get a coffee while the files are being processed.
   This might take a while depending on your traces sizes.

5. Once the traces are processed, your directory will have a bunch of new files.
For each binary `trace.bin.*` file there will be a corresponding `trace.bin.*.txt`.
This file contains the text version of the trace. You can peek into those files to
see all function names and timestamps. For example, you would see records like this:

   ```
   --> __wt_btcur_next 2 334888040634441
   <-- __wt_btcur_next 2 334890966319815
   ```

   The "-->" or "<--" arrows at the beginning of the line indicate whether this is
   the timestamp for entering or exiting the function: "-->" is for entering,
   "<--" is for exiting. The next word is the function name. The number after that
   is the thread id (redundant with the name of the file). The huge number
   following the thread id is the timestamp obtained with `clock_gettime` on
   Linux and `mach_absolute_time` on OS X (these calls are just as fast as reading
   the system time directly from the `rdtsc` register.

   In addition to the text traces, you will also have `trace.bin.*.summary.txt`
   and `trade.bin.*.summary.csv` for each trace file.
   Summary files tell you what functions were executed by
   the corresponding thread, how many times each function was called, and how
   much time it took to execute on average and in total. The text and csv files
   carry equivalent information, but the latter are easier to parse.

   But the best part is the visual summary of the traces, which can be found in
   the new `HTML` directory -- created in the same directory where you processed
   the traces. Just open `HTML/index.html` in your browser. Our [next post](https://dinamite-toolkit.github.io/2016/12/20/interactive-execution-flow-WT) shows
   examples of visual diagrams you will see and explains how to interpret them.

